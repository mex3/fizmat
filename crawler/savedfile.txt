<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Regular Expression HOWTO &mdash; Python 2.7.11 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.7.11',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 2.7.11 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 2.7.11 documentation" href="../contents.html" />
    <link rel="up" title="Python HOWTOs" href="index.html" />
    <link rel="next" title="Socket Programming HOWTO" href="sockets.html" />
    <link rel="prev" title="Logging Cookbook" href="logging-cookbook.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
 
    

  </head>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sockets.html" title="Socket Programming HOWTO"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="logging-cookbook.html" title="Logging Cookbook"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">2.7.11</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python HOWTOs</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="regular-expression-howto">
<span id="regex-howto"></span><h1>Regular Expression HOWTO<a class="headerlink" href="#regular-expression-howto" title="Permalink to this headline"></a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">A.M. Kuchling &lt;<a class="reference external" href="mailto:amk&#37;&#52;&#48;amk&#46;ca">amk<span>&#64;</span>amk<span>&#46;</span>ca</a>&gt;</td>
</tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">Abstract</p>
<p>This document is an introductory tutorial to using regular expressions in Python
with the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module.  It provides a gentler introduction than the
corresponding section in the Library Reference.</p>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>The <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module was added in Python 1.5, and provides Perl-style regular
expression patterns.  Earlier versions of Python came with the <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code>
module, which provided Emacs-style patterns.  The <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code> module was
removed completely in Python 2.5.</p>
<p>Regular expressions (called REs, or regexes, or regex patterns) are essentially
a tiny, highly specialized programming language embedded inside Python and made
available through the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module. Using this little language, you specify
the rules for the set of possible strings that you want to match; this set might
contain English sentences, or e-mail addresses, or TeX commands, or anything you
like.  You can then ask questions such as &#8220;Does this string match the pattern?&#8221;,
or &#8220;Is there a match for the pattern anywhere in this string?&#8221;.  You can also
use REs to modify a string or to split it apart in various ways.</p>
<p>Regular expression patterns are compiled into a series of bytecodes which are
then executed by a matching engine written in C.  For advanced use, it may be
necessary to pay careful attention to how the engine will execute a given RE,
and write the RE in a certain way in order to produce bytecode that runs faster.
Optimization isn&#8217;t covered in this document, because it requires that you have a
good understanding of the matching engine&#8217;s internals.</p>
<p>The regular expression language is relatively small and restricted, so not all
possible string processing tasks can be done using regular expressions.  There
are also tasks that <em>can</em> be done with regular expressions, but the expressions
turn out to be very complicated.  In these cases, you may be better off writing
Python code to do the processing; while Python code will be slower than an
elaborate regular expression, it will also probably be more understandable.</p>
</div>
<div class="section" id="simple-patterns">
<h2>Simple Patterns<a class="headerlink" href="#simple-patterns" title="Permalink to this headline"></a></h2>
<p>We&#8217;ll start by learning about the simplest possible regular expressions.  Since
regular expressions are used to operate on strings, we&#8217;ll begin with the most
common task: matching characters.</p>
<p>For a detailed explanation of the computer science underlying regular
expressions (deterministic and non-deterministic finite automata), you can refer
to almost any textbook on writing compilers.</p>
<div class="section" id="matching-characters">
<h3>Matching Characters<a class="headerlink" href="#matching-characters" title="Permalink to this headline"></a></h3>
<p>Most letters and characters will simply match themselves.  For example, the
regular expression <code class="docutils literal"><span class="pre">test</span></code> will match the string <code class="docutils literal"><span class="pre">test</span></code> exactly.  (You can
enable a case-insensitive mode that would let this RE match <code class="docutils literal"><span class="pre">Test</span></code> or <code class="docutils literal"><span class="pre">TEST</span></code>
as well; more about this later.)</p>
<p>There are exceptions to this rule; some characters are special
<em class="dfn">metacharacters</em>, and don&#8217;t match themselves.  Instead, they signal that
some out-of-the-ordinary thing should be matched, or they affect other portions
of the RE by repeating them or changing their meaning.  Much of this document is
devoted to discussing various metacharacters and what they do.</p>
<p>Here&#8217;s a complete list of the metacharacters; their meanings will be discussed
in the rest of this HOWTO.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>. ^ $ * + ? { } [ ] \ | ( )
</pre></div>
</div>
<p>The first metacharacters we&#8217;ll look at are <code class="docutils literal"><span class="pre">[</span></code> and <code class="docutils literal"><span class="pre">]</span></code>. They&#8217;re used for
specifying a character class, which is a set of characters that you wish to
match.  Characters can be listed individually, or a range of characters can be
indicated by giving two characters and separating them by a <code class="docutils literal"><span class="pre">'-'</span></code>.  For
example, <code class="docutils literal"><span class="pre">[abc]</span></code> will match any of the characters <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>, or <code class="docutils literal"><span class="pre">c</span></code>; this
is the same as <code class="docutils literal"><span class="pre">[a-c]</span></code>, which uses a range to express the same set of
characters.  If you wanted to match only lowercase letters, your RE would be
<code class="docutils literal"><span class="pre">[a-z]</span></code>.</p>
<p>Metacharacters are not active inside classes.  For example, <code class="docutils literal"><span class="pre">[akm$]</span></code> will
match any of the characters <code class="docutils literal"><span class="pre">'a'</span></code>, <code class="docutils literal"><span class="pre">'k'</span></code>, <code class="docutils literal"><span class="pre">'m'</span></code>, or <code class="docutils literal"><span class="pre">'$'</span></code>; <code class="docutils literal"><span class="pre">'$'</span></code> is
usually a metacharacter, but inside a character class it&#8217;s stripped of its
special nature.</p>
<p>You can match the characters not listed within the class by <em class="dfn">complementing</em>
the set.  This is indicated by including a <code class="docutils literal"><span class="pre">'^'</span></code> as the first character of the
class; <code class="docutils literal"><span class="pre">'^'</span></code> outside a character class will simply match the <code class="docutils literal"><span class="pre">'^'</span></code>
character.  For example, <code class="docutils literal"><span class="pre">[^5]</span></code> will match any character except <code class="docutils literal"><span class="pre">'5'</span></code>.</p>
<p>Perhaps the most important metacharacter is the backslash, <code class="docutils literal"><span class="pre">\</span></code>.   As in Python
string literals, the backslash can be followed by various characters to signal
various special sequences.  It&#8217;s also used to escape all the metacharacters so
you can still match them in patterns; for example, if you need to match a <code class="docutils literal"><span class="pre">[</span></code>
or  <code class="docutils literal"><span class="pre">\</span></code>, you can precede them with a backslash to remove their special
meaning: <code class="docutils literal"><span class="pre">\[</span></code> or <code class="docutils literal"><span class="pre">\\</span></code>.</p>
<p>Some of the special sequences beginning with <code class="docutils literal"><span class="pre">'\'</span></code> represent predefined sets
of characters that are often useful, such as the set of digits, the set of
letters, or the set of anything that isn&#8217;t whitespace.  The following predefined
special sequences are a subset of those available. The equivalent classes are
for byte string patterns. For a complete list of sequences and expanded class
definitions for Unicode string patterns, see the last part of
<a class="reference internal" href="../library/re.html#re-syntax"><span>Regular Expression Syntax</span></a>.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">\d</span></code></dt>
<dd>Matches any decimal digit; this is equivalent to the class <code class="docutils literal"><span class="pre">[0-9]</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">\D</span></code></dt>
<dd>Matches any non-digit character; this is equivalent to the class <code class="docutils literal"><span class="pre">[^0-9]</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">\s</span></code></dt>
<dd>Matches any whitespace character; this is equivalent to the class <code class="docutils literal"><span class="pre">[</span>
<span class="pre">\t\n\r\f\v]</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">\S</span></code></dt>
<dd>Matches any non-whitespace character; this is equivalent to the class <code class="docutils literal"><span class="pre">[^</span>
<span class="pre">\t\n\r\f\v]</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">\w</span></code></dt>
<dd>Matches any alphanumeric character; this is equivalent to the class
<code class="docutils literal"><span class="pre">[a-zA-Z0-9_]</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">\W</span></code></dt>
<dd>Matches any non-alphanumeric character; this is equivalent to the class
<code class="docutils literal"><span class="pre">[^a-zA-Z0-9_]</span></code>.</dd>
</dl>
<p>These sequences can be included inside a character class.  For example,
<code class="docutils literal"><span class="pre">[\s,.]</span></code> is a character class that will match any whitespace character, or
<code class="docutils literal"><span class="pre">','</span></code> or <code class="docutils literal"><span class="pre">'.'</span></code>.</p>
<p>The final metacharacter in this section is <code class="docutils literal"><span class="pre">.</span></code>.  It matches anything except a
newline character, and there&#8217;s an alternate mode (<code class="docutils literal"><span class="pre">re.DOTALL</span></code>) where it will
match even a newline.  <code class="docutils literal"><span class="pre">'.'</span></code> is often used where you want to match &#8220;any
character&#8221;.</p>
</div>
<div class="section" id="repeating-things">
<h3>Repeating Things<a class="headerlink" href="#repeating-things" title="Permalink to this headline"></a></h3>
<p>Being able to match varying sets of characters is the first thing regular
expressions can do that isn&#8217;t already possible with the methods available on
strings.  However, if that was the only additional capability of regexes, they
wouldn&#8217;t be much of an advance. Another capability is that you can specify that
portions of the RE must be repeated a certain number of times.</p>
<p>The first metacharacter for repeating things that we&#8217;ll look at is <code class="docutils literal"><span class="pre">*</span></code>.  <code class="docutils literal"><span class="pre">*</span></code>
doesn&#8217;t match the literal character <code class="docutils literal"><span class="pre">*</span></code>; instead, it specifies that the
previous character can be matched zero or more times, instead of exactly once.</p>
<p>For example, <code class="docutils literal"><span class="pre">ca*t</span></code> will match <code class="docutils literal"><span class="pre">ct</span></code> (0 <code class="docutils literal"><span class="pre">a</span></code> characters), <code class="docutils literal"><span class="pre">cat</span></code> (1 <code class="docutils literal"><span class="pre">a</span></code>),
<code class="docutils literal"><span class="pre">caaat</span></code> (3 <code class="docutils literal"><span class="pre">a</span></code> characters), and so forth.  The RE engine has various
internal limitations stemming from the size of C&#8217;s <code class="docutils literal"><span class="pre">int</span></code> type that will
prevent it from matching over 2 billion <code class="docutils literal"><span class="pre">a</span></code> characters; you probably don&#8217;t
have enough memory to construct a string that large, so you shouldn&#8217;t run into
that limit.</p>
<p>Repetitions such as <code class="docutils literal"><span class="pre">*</span></code> are <em class="dfn">greedy</em>; when repeating a RE, the matching
engine will try to repeat it as many times as possible. If later portions of the
pattern don&#8217;t match, the matching engine will then back up and try again with
fewer repetitions.</p>
<p>A step-by-step example will make this more obvious.  Let&#8217;s consider the
expression <code class="docutils literal"><span class="pre">a[bcd]*b</span></code>.  This matches the letter <code class="docutils literal"><span class="pre">'a'</span></code>, zero or more letters
from the class <code class="docutils literal"><span class="pre">[bcd]</span></code>, and finally ends with a <code class="docutils literal"><span class="pre">'b'</span></code>.  Now imagine matching
this RE against the string <code class="docutils literal"><span class="pre">abcbd</span></code>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="22%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Step</th>
<th class="head">Matched</th>
<th class="head">Explanation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td><code class="docutils literal"><span class="pre">a</span></code></td>
<td>The <code class="docutils literal"><span class="pre">a</span></code> in the RE matches.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td><code class="docutils literal"><span class="pre">abcbd</span></code></td>
<td>The engine matches <code class="docutils literal"><span class="pre">[bcd]*</span></code>,
going as far as it can, which
is to the end of the string.</td>
</tr>
<tr class="row-even"><td>3</td>
<td><em>Failure</em></td>
<td>The engine tries to match
<code class="docutils literal"><span class="pre">b</span></code>, but the current position
is at the end of the string, so
it fails.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td><code class="docutils literal"><span class="pre">abcb</span></code></td>
<td>Back up, so that  <code class="docutils literal"><span class="pre">[bcd]*</span></code>
matches one less character.</td>
</tr>
<tr class="row-even"><td>5</td>
<td><em>Failure</em></td>
<td>Try <code class="docutils literal"><span class="pre">b</span></code> again, but the
current position is at the last
character, which is a <code class="docutils literal"><span class="pre">'d'</span></code>.</td>
</tr>
<tr class="row-odd"><td>6</td>
<td><code class="docutils literal"><span class="pre">abc</span></code></td>
<td>Back up again, so that
<code class="docutils literal"><span class="pre">[bcd]*</span></code> is only matching
<code class="docutils literal"><span class="pre">bc</span></code>.</td>
</tr>
<tr class="row-even"><td>6</td>
<td><code class="docutils literal"><span class="pre">abcb</span></code></td>
<td>Try <code class="docutils literal"><span class="pre">b</span></code> again.  This time
the character at the
current position is <code class="docutils literal"><span class="pre">'b'</span></code>, so
it succeeds.</td>
</tr>
</tbody>
</table>
<p>The end of the RE has now been reached, and it has matched <code class="docutils literal"><span class="pre">abcb</span></code>.  This
demonstrates how the matching engine goes as far as it can at first, and if no
match is found it will then progressively back up and retry the rest of the RE
again and again.  It will back up until it has tried zero matches for
<code class="docutils literal"><span class="pre">[bcd]*</span></code>, and if that subsequently fails, the engine will conclude that the
string doesn&#8217;t match the RE at all.</p>
<p>Another repeating metacharacter is <code class="docutils literal"><span class="pre">+</span></code>, which matches one or more times.  Pay
careful attention to the difference between <code class="docutils literal"><span class="pre">*</span></code> and <code class="docutils literal"><span class="pre">+</span></code>; <code class="docutils literal"><span class="pre">*</span></code> matches
<em>zero</em> or more times, so whatever&#8217;s being repeated may not be present at all,
while <code class="docutils literal"><span class="pre">+</span></code> requires at least <em>one</em> occurrence.  To use a similar example,
<code class="docutils literal"><span class="pre">ca+t</span></code> will match <code class="docutils literal"><span class="pre">cat</span></code> (1 <code class="docutils literal"><span class="pre">a</span></code>), <code class="docutils literal"><span class="pre">caaat</span></code> (3 <code class="docutils literal"><span class="pre">a</span></code>&#8216;s), but won&#8217;t match
<code class="docutils literal"><span class="pre">ct</span></code>.</p>
<p>There are two more repeating qualifiers.  The question mark character, <code class="docutils literal"><span class="pre">?</span></code>,
matches either once or zero times; you can think of it as marking something as
being optional.  For example, <code class="docutils literal"><span class="pre">home-?brew</span></code> matches either <code class="docutils literal"><span class="pre">homebrew</span></code> or
<code class="docutils literal"><span class="pre">home-brew</span></code>.</p>
<p>The most complicated repeated qualifier is <code class="docutils literal"><span class="pre">{m,n}</span></code>, where <em>m</em> and <em>n</em> are
decimal integers.  This qualifier means there must be at least <em>m</em> repetitions,
and at most <em>n</em>.  For example, <code class="docutils literal"><span class="pre">a/{1,3}b</span></code> will match <code class="docutils literal"><span class="pre">a/b</span></code>, <code class="docutils literal"><span class="pre">a//b</span></code>, and
<code class="docutils literal"><span class="pre">a///b</span></code>.  It won&#8217;t match <code class="docutils literal"><span class="pre">ab</span></code>, which has no slashes, or <code class="docutils literal"><span class="pre">a////b</span></code>, which
has four.</p>
<p>You can omit either <em>m</em> or <em>n</em>; in that case, a reasonable value is assumed for
the missing value.  Omitting <em>m</em> is interpreted as a lower limit of 0, while
omitting <em>n</em> results in an upper bound of infinity &#8212; actually, the upper bound
is the 2-billion limit mentioned earlier, but that might as well be infinity.</p>
<p>Readers of a reductionist bent may notice that the three other qualifiers can
all be expressed using this notation.  <code class="docutils literal"><span class="pre">{0,}</span></code> is the same as <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">{1,}</span></code>
is equivalent to <code class="docutils literal"><span class="pre">+</span></code>, and <code class="docutils literal"><span class="pre">{0,1}</span></code> is the same as <code class="docutils literal"><span class="pre">?</span></code>.  It&#8217;s better to use
<code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">+</span></code>, or <code class="docutils literal"><span class="pre">?</span></code> when you can, simply because they&#8217;re shorter and easier
to read.</p>
</div>
</div>
<div class="section" id="using-regular-expressions">
<h2>Using Regular Expressions<a class="headerlink" href="#using-regular-expressions" title="Permalink to this headline"></a></h2>
<p>Now that we&#8217;ve looked at some simple regular expressions, how do we actually use
them in Python?  The <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module provides an interface to the regular
expression engine, allowing you to compile REs into objects and then perform
matches with them.</p>
<div class="section" id="compiling-regular-expressions">
<h3>Compiling Regular Expressions<a class="headerlink" href="#compiling-regular-expressions" title="Permalink to this headline"></a></h3>
<p>Regular expressions are compiled into pattern objects, which have
methods for various operations such as searching for pattern matches or
performing string substitutions.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;ab*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>  
<span class="go">&lt;_sre.SRE_Pattern object at 0x...&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal"><span class="pre">re.compile()</span></code></a> also accepts an optional <em>flags</em> argument, used to enable
various special features and syntax variations.  We&#8217;ll go over the available
settings later, but for now a single example will do:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;ab*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
</pre></div>
</div>
<p>The RE is passed to <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal"><span class="pre">re.compile()</span></code></a> as a string.  REs are handled as strings
because regular expressions aren&#8217;t part of the core Python language, and no
special syntax was created for expressing them.  (There are applications that
don&#8217;t need REs at all, so there&#8217;s no need to bloat the language specification by
including them.) Instead, the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module is simply a C extension module
included with Python, just like the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> or <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal"><span class="pre">zlib</span></code></a> modules.</p>
<p>Putting REs in strings keeps the Python language simpler, but has one
disadvantage which is the topic of the next section.</p>
</div>
<div class="section" id="the-backslash-plague">
<h3>The Backslash Plague<a class="headerlink" href="#the-backslash-plague" title="Permalink to this headline"></a></h3>
<p>As stated earlier, regular expressions use the backslash character (<code class="docutils literal"><span class="pre">'\'</span></code>) to
indicate special forms or to allow special characters to be used without
invoking their special meaning. This conflicts with Python&#8217;s usage of the same
character for the same purpose in string literals.</p>
<p>Let&#8217;s say you want to write a RE that matches the string <code class="docutils literal"><span class="pre">\section</span></code>, which
might be found in a LaTeX file.  To figure out what to write in the program
code, start with the desired string to be matched.  Next, you must escape any
backslashes and other metacharacters by preceding them with a backslash,
resulting in the string <code class="docutils literal"><span class="pre">\\section</span></code>.  The resulting string that must be passed
to <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal"><span class="pre">re.compile()</span></code></a> must be <code class="docutils literal"><span class="pre">\\section</span></code>.  However, to express this as a
Python string literal, both backslashes must be escaped <em>again</em>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Characters</th>
<th class="head">Stage</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">\section</span></code></td>
<td>Text string to be matched</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">\\section</span></code></td>
<td>Escaped backslash for <a class="reference internal" href="../library/re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal"><span class="pre">re.compile()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&quot;\\\\section&quot;</span></code></td>
<td>Escaped backslashes for a string literal</td>
</tr>
</tbody>
</table>
<p>In short, to match a literal backslash, one has to write <code class="docutils literal"><span class="pre">'\\\\'</span></code> as the RE
string, because the regular expression must be <code class="docutils literal"><span class="pre">\\</span></code>, and each backslash must
be expressed as <code class="docutils literal"><span class="pre">\\</span></code> inside a regular Python string literal.  In REs that
feature backslashes repeatedly, this leads to lots of repeated backslashes and
makes the resulting strings difficult to understand.</p>
<p>The solution is to use Python&#8217;s raw string notation for regular expressions;
backslashes are not handled in any special way in a string literal prefixed with
<code class="docutils literal"><span class="pre">'r'</span></code>, so <code class="docutils literal"><span class="pre">r&quot;\n&quot;</span></code> is a two-character string containing <code class="docutils literal"><span class="pre">'\'</span></code> and <code class="docutils literal"><span class="pre">'n'</span></code>,
while <code class="docutils literal"><span class="pre">&quot;\n&quot;</span></code> is a one-character string containing a newline. Regular
expressions will often be written in Python code using this raw string notation.</p>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Regular String</th>
<th class="head">Raw string</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&quot;ab*&quot;</span></code></td>
<td><code class="docutils literal"><span class="pre">r&quot;ab*&quot;</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&quot;\\\\section&quot;</span></code></td>
<td><code class="docutils literal"><span class="pre">r&quot;\\section&quot;</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&quot;\\w+\\s+\\1&quot;</span></code></td>
<td><code class="docutils literal"><span class="pre">r&quot;\w+\s+\1&quot;</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="performing-matches">
<h3>Performing Matches<a class="headerlink" href="#performing-matches" title="Permalink to this headline"></a></h3>
<p>Once you have an object representing a compiled regular expression, what do you
do with it?  Pattern objects have several methods and attributes.
Only the most significant ones will be covered here; consult the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> docs
for a complete listing.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method/Attribute</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">match()</span></code></td>
<td>Determine if the RE matches at the beginning
of the string.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">search()</span></code></td>
<td>Scan through a string, looking for any
location where this RE matches.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">findall()</span></code></td>
<td>Find all substrings where the RE matches, and
returns them as a list.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">finditer()</span></code></td>
<td>Find all substrings where the RE matches, and
returns them as an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>.</td>
</tr>
</tbody>
</table>
<p><code class="xref py py-meth docutils literal"><span class="pre">match()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">search()</span></code> return <code class="docutils literal"><span class="pre">None</span></code> if no match can be found.  If
they&#8217;re successful, a <a class="reference internal" href="../library/re.html#match-objects"><span>match object</span></a> instance is returned,
containing information about the match: where it starts and ends, the substring
it matched, and more.</p>
<p>You can learn about this by interactively experimenting with the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a>
module.  If you have Tkinter available, you may also want to look at
<a class="reference external" href="https://hg.python.org/cpython/file/2.7/Tools/scripts/redemo.py">Tools/scripts/redemo.py</a>, a demonstration program included with the
Python distribution.  It allows you to enter REs and strings, and displays
whether the RE matches or fails. <code class="file docutils literal"><span class="pre">redemo.py</span></code> can be quite useful when
trying to debug a complicated RE.  Phil Schwartz&#8217;s <a class="reference external" href="http://kodos.sourceforge.net/">Kodos</a> is also an interactive tool for developing and
testing RE patterns.</p>
<p>This HOWTO uses the standard Python interpreter for its examples. First, run the
Python interpreter, import the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module, and compile a RE:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>Python 2.2.2 (#1, Feb 10 2003, 12:57:01)
&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile(&#39;[a-z]+&#39;)
&gt;&gt;&gt; p  #doctest: +ELLIPSIS
&lt;_sre.SRE_Pattern object at 0x...&gt;
</pre></div>
</div>
<p>Now, you can try matching various strings against the RE <code class="docutils literal"><span class="pre">[a-z]+</span></code>.  An empty
string shouldn&#8217;t match at all, since <code class="docutils literal"><span class="pre">+</span></code> means &#8216;one or more repetitions&#8217;.
<code class="xref py py-meth docutils literal"><span class="pre">match()</span></code> should return <code class="docutils literal"><span class="pre">None</span></code> in this case, which will cause the
interpreter to print no output.  You can explicitly print the result of
<code class="xref py py-meth docutils literal"><span class="pre">match()</span></code> to make this clear.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Now, let&#8217;s try it on a string that it should match, such as <code class="docutils literal"><span class="pre">tempo</span></code>.  In this
case, <code class="xref py py-meth docutils literal"><span class="pre">match()</span></code> will return a <a class="reference internal" href="../library/re.html#match-objects"><span>match object</span></a>, so you
should store the result in a variable for later use.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;tempo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>  
<span class="go">&lt;_sre.SRE_Match object at 0x...&gt;</span>
</pre></div>
</div>
<p>Now you can query the <a class="reference internal" href="../library/re.html#match-objects"><span>match object</span></a> for information
about the matching string.  <a class="reference internal" href="../library/re.html#match-objects"><span>match object</span></a> instances
also have several methods and attributes; the most important ones are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method/Attribute</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">group()</span></code></td>
<td>Return the string matched by the RE</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">start()</span></code></td>
<td>Return the starting position of the match</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">end()</span></code></td>
<td>Return the ending position of the match</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">span()</span></code></td>
<td>Return a tuple containing the (start, end)
positions  of the match</td>
</tr>
</tbody>
</table>
<p>Trying these methods will soon clarify their meaning:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;tempo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
<span class="go">(0, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">(0, 5)</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal"><span class="pre">group()</span></code> returns the substring that was matched by the RE.  <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code>
and <code class="xref py py-meth docutils literal"><span class="pre">end()</span></code> return the starting and ending index of the match. <code class="xref py py-meth docutils literal"><span class="pre">span()</span></code>
returns both start and end indexes in a single tuple.  Since the <code class="xref py py-meth docutils literal"><span class="pre">match()</span></code>
method only checks if the RE matches at the start of a string, <code class="xref py py-meth docutils literal"><span class="pre">start()</span></code>
will always be zero.  However, the <code class="xref py py-meth docutils literal"><span class="pre">search()</span></code> method of patterns
scans through the string, so  the match may not start at zero in that
case.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;::: message&#39;</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;::: message&#39;</span><span class="p">);</span> <span class="k">print</span> <span class="n">m</span>  
<span class="go">&lt;_sre.SRE_Match object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="go">&#39;message&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">(4, 11)</span>
</pre></div>
</div>
<p>In actual programs, the most common style is to store the
<a class="reference internal" href="../library/re.html#match-objects"><span>match object</span></a> in a variable, and then check if it was
<code class="docutils literal"><span class="pre">None</span></code>.  This usually looks like:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">match</span><span class="p">(</span> <span class="s1">&#39;string goes here&#39;</span> <span class="p">)</span>
<span class="k">if</span> <span class="n">m</span><span class="p">:</span>
    <span class="k">print</span> <span class="s1">&#39;Match found: &#39;</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s1">&#39;No match&#39;</span>
</pre></div>
</div>
<p>Two pattern methods return all of the matches for a pattern.
<code class="xref py py-meth docutils literal"><span class="pre">findall()</span></code> returns a list of matching strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;12 drummers drumming, 11 pipers piping, 10 lords a-leaping&#39;</span><span class="p">)</span>
<span class="go">[&#39;12&#39;, &#39;11&#39;, &#39;10&#39;]</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal"><span class="pre">findall()</span></code> has to create the entire list before it can be returned as the
result.  The <code class="xref py py-meth docutils literal"><span class="pre">finditer()</span></code> method returns a sequence of
<a class="reference internal" href="../library/re.html#match-objects"><span>match object</span></a> instances as an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. <a class="footnote-reference" href="#id3" id="id1">[1]</a></p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s1">&#39;12 drummers drumming, 11 ... 10 ...&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iterator</span>  
<span class="go">&lt;callable-iterator object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">match</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">(0, 2)</span>
<span class="go">(22, 24)</span>
<span class="go">(29, 31)</span>
</pre></div>
</div>
</div>
<div class="section" id="module-level-functions">
<h3>Module-Level Functions<a class="headerlink" href="#module-level-functions" title="Permalink to this headline"></a></h3>
<p>You don&#8217;t have to create a pattern object and call its methods; the
<a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module also provides top-level functions called <code class="xref py py-func docutils literal"><span class="pre">match()</span></code>,
<code class="xref py py-func docutils literal"><span class="pre">search()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">findall()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">sub()</span></code>, and so forth.  These functions
take the same arguments as the corresponding pattern method, with
the RE string added as the first argument, and still return either <code class="docutils literal"><span class="pre">None</span></code> or a
<a class="reference internal" href="../library/re.html#match-objects"><span>match object</span></a> instance.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">r&#39;From\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;Fromage amk&#39;</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">r&#39;From\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;From amk Thu May 14 19:12:10 1998&#39;</span><span class="p">)</span>  
<span class="go">&lt;_sre.SRE_Match object at 0x...&gt;</span>
</pre></div>
</div>
<p>Under the hood, these functions simply create a pattern object for you
and call the appropriate method on it.  They also store the compiled object in a
cache, so future calls using the same RE are faster.</p>
<p>Should you use these module-level functions, or should you get the
pattern and call its methods yourself?  That choice depends on how
frequently the RE will be used, and on your personal coding style.  If the RE is
being used at only one point in the code, then the module functions are probably
more convenient.  If a program contains a lot of regular expressions, or re-uses
the same ones in several locations, then it might be worthwhile to collect all
the definitions in one place, in a section of code that compiles all the REs
ahead of time.  To take an example from the standard library, here&#8217;s an extract
from the deprecated <code class="xref py py-mod docutils literal"><span class="pre">xmllib</span></code> module:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">entityref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">charref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">starttagopen</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
</pre></div>
</div>
<p>I generally prefer to work with the compiled object, even for one-time uses, but
few people will be as much of a purist about this as I am.</p>
</div>
<div class="section" id="compilation-flags">
<h3>Compilation Flags<a class="headerlink" href="#compilation-flags" title="Permalink to this headline"></a></h3>
<p>Compilation flags let you modify some aspects of how regular expressions work.
Flags are available in the <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> module under two names, a long name such as
<code class="xref py py-const docutils literal"><span class="pre">IGNORECASE</span></code> and a short, one-letter form such as <code class="xref py py-const docutils literal"><span class="pre">I</span></code>.  (If you&#8217;re
familiar with Perl&#8217;s pattern modifiers, the one-letter forms use the same
letters; the short form of <a class="reference internal" href="../library/re.html#re.VERBOSE" title="re.VERBOSE"><code class="xref py py-const docutils literal"><span class="pre">re.VERBOSE</span></code></a> is <a class="reference internal" href="../library/re.html#re.X" title="re.X"><code class="xref py py-const docutils literal"><span class="pre">re.X</span></code></a>, for example.)
Multiple flags can be specified by bitwise OR-ing them; <code class="docutils literal"><span class="pre">re.I</span> <span class="pre">|</span> <span class="pre">re.M</span></code> sets
both the <code class="xref py py-const docutils literal"><span class="pre">I</span></code> and <code class="xref py py-const docutils literal"><span class="pre">M</span></code> flags, for example.</p>
<p>Here&#8217;s a table of the available flags, followed by a more detailed explanation
of each one.</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Flag</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">DOTALL</span></code>, <code class="xref py py-const docutils literal"><span class="pre">S</span></code></td>
<td>Make <code class="docutils literal"><span class="pre">.</span></code> match any character, including
newlines</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">IGNORECASE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">I</span></code></td>
<td>Do case-insensitive matches</td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">LOCALE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">L</span></code></td>
<td>Do a locale-aware match</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">MULTILINE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">M</span></code></td>
<td>Multi-line matching, affecting <code class="docutils literal"><span class="pre">^</span></code> and
<code class="docutils literal"><span class="pre">$</span></code></td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">VERBOSE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">X</span></code></td>
<td>Enable verbose REs, which can be organized
more cleanly and understandably.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">UNICODE</span></code>, <code class="xref py py-const docutils literal"><span class="pre">U</span></code></td>
<td>Makes several escapes like <code class="docutils literal"><span class="pre">\w</span></code>, <code class="docutils literal"><span class="pre">\b</span></code>,
<code class="docutils literal"><span class="pre">\s</span></code> and <code class="docutils literal"><span class="pre">\d</span></code> dependent on the Unicode
character database.</td>
</tr>
</tbody>
</table>
<dl class="data">